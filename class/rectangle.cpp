#include <iostream>
using namespace std;

class CRectangle {
  int *width, *height;  // pointers...
  public:
  // overloaded constructors
  CRectangle ();  
  CRectangle (int,int);

  ~CRectangle ();
  int area () {return (*width * *height);}
};

/*  implictly generated by the compiler so we can use copy
 *  assignment operator= directly
CRectangle& CRectangle::operator= (const CRectangle& param)
{
  x=param.width;
  y=param.height;
  return *this;
}
*/

CRectangle::CRectangle (int a, int b) {
  width = new int;
  height = new int;
  *width = a;
  *height = b;
}

CRectangle::CRectangle () {
  width = new int;
  height = new int;
  *width = 5;
  *height = 5;
}

CRectangle::~CRectangle () {
  delete width;
  delete height;
}

int main () {
  CRectangle rect1 (3,4);
  CRectangle rect2 (5,6);
  CRectangle rect3; // no ()
  CRectangle rect4;
  CRectangle rect5(rect3);
  rect4 = rect3;     // copy assignment operator 

  cout << "rect1 area: " << rect1.area() << endl;
  cout << "rect2 area: " << rect2.area() << endl;
  cout << "rect3 area: " << rect3.area() << endl;
  cout << "copy: rect4 area: " << rect4.area() << endl;
  cout << "copy: rect5 area: " << rect5.area() << endl;

  CRectangle *cp_rect1; 
  CRectangle *cp_rect2; 
  CRectangle *cp_rect3;

  cp_rect1 = new CRectangle(1,2);
  cp_rect2 = new CRectangle(3,4);
  cp_rect3 = new CRectangle[2];   // pointer to two objects
  /* init ?
  cp_rect3[0]->set_values (5,6);
  cp_rect3[1]->set_values (6,7);
  */

  cout << "rect1    area: " << cp_rect1->area() << endl;
  cout << "rect2    area: " << cp_rect2->area() << endl;
  cout << "rect3[0] area: " << cp_rect3[0].area() << endl; // error if . is ->
  cout << "rect3[1] area: " << cp_rect3[1].area() << endl; // error if . is ->
  return 0;
}
